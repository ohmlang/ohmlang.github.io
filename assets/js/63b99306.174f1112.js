"use strict";(self.webpackChunkohmjs_org=self.webpackChunkohmjs_org||[]).push([[619],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(n),u=r,h=c["".concat(p,".").concat(u)]||c[u]||m[u]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1506:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return p},default:function(){return u},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return m}});var a=n(3117),r=n(102),i=(n(7294),n(3905)),o=["components"],l={},p="Patterns and Pitfalls",s={unversionedId:"patterns-and-pitfalls",id:"patterns-and-pitfalls",title:"Patterns and Pitfalls",description:"Grammars",source:"@site/docs/patterns-and-pitfalls.md",sourceDirName:".",slug:"/patterns-and-pitfalls",permalink:"/docs/patterns-and-pitfalls",editUrl:"https://github.com/harc/ohm/edit/main/doc/patterns-and-pitfalls.md",tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"Ohm v16.0",permalink:"/docs/releases/ohm-js-16.0"}},d={},m=[{value:"Grammars",id:"grammars",level:2},{value:"Dealing with greedy matching",id:"dealing-with-greedy-matching",level:3},{value:"Delimited strings",id:"delimited-strings",level:3},{value:"Supporting comments",id:"supporting-comments",level:3},{value:"Reserved words / keywords",id:"reserved-words--keywords",level:3},{value:"Matching exactly <em>n</em> times",id:"matching-exactly-n-times",level:3},{value:"Operator precedence",id:"operator-precedence",level:3},{value:"\ud83d\udc0d Ambiguous recursion",id:"-ambiguous-recursion",level:4},{value:"Semantics",id:"semantics",level:2},{value:"Iteration nodes",id:"iteration-nodes",level:3},{value:"Optional nodes",id:"optional-nodes",level:4},{value:"Handling the built-in list rules",id:"handling-the-built-in-list-rules",level:3}],c={toc:m};function u(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"patterns-and-pitfalls"},"Patterns and Pitfalls"),(0,i.kt)("h2",{id:"grammars"},"Grammars"),(0,i.kt)("h3",{id:"dealing-with-greedy-matching"},"Dealing with greedy matching"),(0,i.kt)("p",null,"In Ohm, like other PEG-based tools, the ",(0,i.kt)("a",{parentName:"p",href:"/docs/syntax-reference#repetition-operators---"},"repetition operators")," ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," are ",(0,i.kt)("em",{parentName:"p"},"greedy"),", meaning they always consume as much input as possible. This is different than the way that ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," works in regular expressions. For example, the regular expression ",(0,i.kt)("inlineCode",{parentName:"p"},"/^a*a/")," will successfully match ",(0,i.kt)("inlineCode",{parentName:"p"},"'aaa'"),", whereas in Ohm, the equivalent parsing expression ",(0,i.kt)("inlineCode",{parentName:"p"},'"a"* "a"')," can never match any input."),(0,i.kt)("p",null,"You can use ",(0,i.kt)("a",{parentName:"p",href:"/docs/syntax-reference#negative-lookahead-"},"negative lookahead")," (",(0,i.kt)("inlineCode",{parentName:"p"},"~"),") to prevent a repetition from matching too many characters. E.g., the following rule will match all but the last 'a' in a string:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'allButLastA = (~("a" end) "a")*\n')),(0,i.kt)("p",null,"The expression ",(0,i.kt)("inlineCode",{parentName:"p"},'"a" end')," means \"match an 'a' at the end of the input\", and ",(0,i.kt)("inlineCode",{parentName:"p"},'~("a" end) "a"')," means \"match an 'a' only if it is not the last 'a' at the end of the input\"."),(0,i.kt)("p",null,"For a more realistic example, see the next section on delimited strings."),(0,i.kt)("h3",{id:"delimited-strings"},"Delimited strings"),(0,i.kt)("p",null,"A common use for negative lookahead is implementing delimited strings and comments. For example, to support JavaScript-style multiline strings delimited by ",(0,i.kt)("inlineCode",{parentName:"p"},"`"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'stringDelimiter = "`"\nstring = stringDelimiter (~stringDelimiter any)* stringDelimiter\n')),(0,i.kt)("p",null,"The expression ",(0,i.kt)("inlineCode",{parentName:"p"},"~stringDelimiter any"),' means "match any character not matched by ',(0,i.kt)("em",{parentName:"p"},"stringDelimiter"),'".'),(0,i.kt)("h3",{id:"supporting-comments"},"Supporting comments"),(0,i.kt)("p",null,"In most languages, comments are treated as a form of whitespace. Ohm has implicit space skipping (",(0,i.kt)("a",{parentName:"p",href:"/docs/syntax-reference#syntactic-vs-lexical-rules"},"see Syntactic vs. Lexical rules"),"), which is controlled by the ",(0,i.kt)("em",{parentName:"p"},"space")," rule. To add comments to your language, you first need to define a ",(0,i.kt)("em",{parentName:"p"},"comment")," rule. Here's an example of C-style (",(0,i.kt)("inlineCode",{parentName:"p"},"/*"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"*/"),"-delimited) comments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'comment = "/*" (~"*/" any)* "*/"\n')),(0,i.kt)("p",null,"Then, you need to extend the ",(0,i.kt)("em",{parentName:"p"},"space")," rule in your grammar so that Ohm will treat the comments as whitespace:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"space += comment\n")),(0,i.kt)("h3",{id:"reserved-words--keywords"},"Reserved words / keywords"),(0,i.kt)("p",null,"Many programming languages have the concept of ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Reserved_word"},"reserved words")," \u2014 identifiers that have a special meaning, and can't be used as the name of a variable, function, etc. In Ohm grammars, it's common to define a separate lexical rule for each reserved word. For example, here's the definition of ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/harc/ohm/blob/c7dcbb6b97366daf54349ba8e5be9133978f5c83/examples/ecmascript/src/es5.ohm#L87"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"keyword")," rule in our ES5 grammar"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  keyword = break    | do        | instanceof | typeof\n          | case     | else      | new        | var\n          | catch    | finally   | return     | void\n          | continue | for       | switch     | while\n          | debugger | function  | this       | with\n          | default  | if        | throw\n          | delete   | in        | try\n")),(0,i.kt)("p",null,"\ud83d\udc0d There are a couple of things to watch out for:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"One reserved word might be a prefix of another, e.g., ",(0,i.kt)("inlineCode",{parentName:"li"},"in")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"instanceof")," in JavaScript."),(0,i.kt)("li",{parentName:"ul"},"Identifiers that begin with a reserved word shouldn't be disallowed, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"className"),".")),(0,i.kt)("p",null,"To prevent both of these potential problems, you can use ",(0,i.kt)("a",{parentName:"p",href:"/docs/syntax-reference#negative-lookahead-"},"negative lookahead")," in the rules for your reserved words. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'  in = "in" ~identifierPart\n')),(0,i.kt)("p",null,"This ensures that (a) the ",(0,i.kt)("inlineCode",{parentName:"p"},"in"),' rule won\'t accidentally match the wrong keyword (like "instanceof"), and (b) it won\'t match a valid identifier like "inProgress".'),(0,i.kt)("h3",{id:"matching-exactly-n-times"},"Matching exactly ",(0,i.kt)("em",{parentName:"h3"},"n")," times"),(0,i.kt)("p",null,"Unlike regular expressions, Ohm does not support ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Quantifiers"},"quantifier")," syntax to indicate the number of times an expression should be matched. However, this can be implemented using a normal sequence:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zipCode = digit digit digit digit\n")),(0,i.kt)("h3",{id:"operator-precedence"},"Operator precedence"),(0,i.kt)("p",null,"The common way to handle operator precedence in Ohm is to use left-recursive rules which encode the precedence in the grammar structure. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'  exp = addExp\n\n  addExp = addExp "+" mulExp  -- plus\n         | addExp "-" mulExp  -- minus\n         | mulExp\n\n  mulExp = mulExp "*" priExp  -- times\n         | mulExp "/" priExp  -- divide\n         | priExp\n')),(0,i.kt)("p",null,"Note that the rule for the lower precedence operators (",(0,i.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),") invokes the rule for the higher-precedence operators (",(0,i.kt)("inlineCode",{parentName:"p"},"*"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"/"),'). This ensures that the higher-precedence operators "bind more tightly". See Ray Toal\'s ',(0,i.kt)("a",{parentName:"p",href:"https://github.com/harc/ohm/tree/main/examples/operators"},"Operator Precedence and Associativity Examples")," for more."),(0,i.kt)("h4",{id:"-ambiguous-recursion"},"\ud83d\udc0d Ambiguous recursion"),(0,i.kt)("p",null,"Notice that in the arithmetic grammar above, ",(0,i.kt)("inlineCode",{parentName:"p"},"mulExp")," appears on the right hand side of all of ",(0,i.kt)("inlineCode",{parentName:"p"},"addExp"),"'s cases. Be careful that you don't write rules that are \"ambiguously recursive\", e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},'addExp = addExp "+" addExp'),". If you write your grammar like this, a reader can't tell whether ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," is left-associative or right-associative. (In Ohm, you will actually get a right-assiciative parse \u2014 see ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/harc/ohm/issues/56"},"#56")," for details.)"),(0,i.kt)("h2",{id:"semantics"},"Semantics"),(0,i.kt)("h3",{id:"iteration-nodes"},"Iteration nodes"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Iteration nodes")," are associated with expressions inside a repetition operator (",(0,i.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),"). E.g., for the grammar ",(0,i.kt)("inlineCode",{parentName:"p"},"G { letters = letter+ }"),", the single argument to the ",(0,i.kt)("em",{parentName:"p"},"letters")," action will be an iteration node. There are two main ways to handle iteration nodes inside semantic actions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Use array operations (",(0,i.kt)("inlineCode",{parentName:"li"},"map"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"filter"),", etc.) on the node's ",(0,i.kt)("inlineCode",{parentName:"li"},"children")," attribute. For example, ",(0,i.kt)("inlineCode",{parentName:"li"},"iterNode.children.map(c => c.prettyPrint())")," would invoke the ",(0,i.kt)("inlineCode",{parentName:"li"},"prettyPrint")," operation on each child of the iteration node."),(0,i.kt)("li",{parentName:"ol"},"Define an ",(0,i.kt)("em",{parentName:"li"},"_","iter")," action for your operation, which allows you to write something like ",(0,i.kt)("inlineCode",{parentName:"li"},"iterNode.prettyPrint()"),". If you have not defined an ",(0,i.kt)("em",{parentName:"li"},"_","iter"),' action for the operation, this will result in a "missing semantic action" error.')),(0,i.kt)("h4",{id:"optional-nodes"},"Optional nodes"),(0,i.kt)("p",null,"An optional node (associated with the ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," operator) is just an iteration node with at most one child. In modern JavaScript (EMCAScript 2020+) and TypeScript, the ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining"},"optional chaining operator")," provides a convenient way to deal with optional nodes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"optNode.child(0)?.myOperation();\n")),(0,i.kt)("p",null,"This evaluates to either (a) ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),", if the node has no child, or (b) the result of calling ",(0,i.kt)("inlineCode",{parentName:"p"},"myOperation()")," on the child. In older versions of JavaScript, you can achieve the same thing via ",(0,i.kt)("inlineCode",{parentName:"p"},"optNode.child(0) && optNode.child(0).myOperation()"),". Another way to do the same thing is: ",(0,i.kt)("inlineCode",{parentName:"p"},"optNode.children.map(c => c.myOperation())[0]"),"."),(0,i.kt)("h3",{id:"handling-the-built-in-list-rules"},"Handling the built-in list rules"),(0,i.kt)("p",null,"When using the built-in list rules (",(0,i.kt)("inlineCode",{parentName:"p"},"listOf"),", etc.) in your grammar, you usually don't need to write semantic actions for them. Instead, you can use the ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference#asIteration"},"built-in ",(0,i.kt)("inlineCode",{parentName:"a"},"asIteration")," operation"),"."))}u.isMDXComponent=!0}}]);