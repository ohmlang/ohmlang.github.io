"use strict";(self.webpackChunkohmjs_org=self.webpackChunkohmjs_org||[]).push([[491],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return h}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=p(a),h=r,d=u["".concat(l,".").concat(h)]||u[h]||c[h]||i;return a?n.createElement(d,o(o({ref:t},m),{},{components:a})):n.createElement(d,o({ref:t},m))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1082:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return c}});var n=a(3117),r=a(102),i=(a(7294),a(3905)),o=["components"],s={},l="API Reference",p={unversionedId:"api-reference",id:"api-reference",title:"API Reference",description:"This page documents the API of Ohm/JS, a JavaScript library for working with grammars written in the Ohm language. For documentation on the Ohm language, see the syntax reference.",source:"@site/docs/api-reference.md",sourceDirName:".",slug:"/api-reference",permalink:"/docs/api-reference",editUrl:"https://github.com/harc/ohm/edit/main/doc/api-reference.md",tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"Syntax Reference",permalink:"/docs/syntax-reference"},next:{title:"Ohm Extras",permalink:"/docs/extras"}},m={},c=[{value:"Instantiating Grammars",id:"instantiating-grammars",level:2},{value:"Grammar objects",id:"grammar-objects",level:2},{value:"Matcher objects",id:"matcher-objects",level:2},{value:"MatchResult objects",id:"matchresult-objects",level:2},{value:"MatchFailure objects",id:"matchfailure-objects",level:3},{value:"Semantics objects",id:"semantics-objects",level:3},{value:"Semantic Actions",id:"semantic-actions",level:3},{value:"Parse Nodes",id:"parse-nodes",level:3},{value:"Operations and Attributes",id:"operations-and-attributes",level:4},{value:"Built-in Operations",id:"built-in-operations",level:2},{value:"asIteration",id:"asiteration",level:3}],u={toc:c};function h(e){var t=e.components,a=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"api-reference"},"API Reference"),(0,i.kt)("p",null,"This page documents the API of Ohm/JS, a JavaScript library for working with grammars written in the Ohm language. For documentation on the Ohm language, see the ",(0,i.kt)("a",{parentName:"p",href:"/docs/syntax-reference"},"syntax reference"),"."),(0,i.kt)("h2",{id:"instantiating-grammars"},"Instantiating Grammars"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NOTE:")," For grammars defined in a JavaScript string literal (i.e., not in a separate .ohm file), it's recommended to use a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw"},"template literal with the String.raw tag"),"."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"ohm.grammar(source: string, optNamespace?: object) \u2192 Grammar")),(0,i.kt)("p",null,"Instantiate the Grammar defined by ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),". If specified, ",(0,i.kt)("inlineCode",{parentName:"p"},"optNamespace")," is an object in which references to other grammars should be resolved. For example, if the grammar source begins with an inheritance declaration like ",(0,i.kt)("inlineCode",{parentName:"p"},"MyGrammar <: OtherGrammar { ... }"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"optNamespace")," should have a property named ",(0,i.kt)("inlineCode",{parentName:"p"},"OtherGrammar"),"."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"ohm.grammars(source: string, optNamespace?: object) \u2192 object")),(0,i.kt)("p",null,"Create a new object containing Grammar instances for all of the grammars defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),". As with ",(0,i.kt)("inlineCode",{parentName:"p"},"ohm.grammar"),", if ",(0,i.kt)("inlineCode",{parentName:"p"},"optNamespace")," is specified, it is an object in which references to other grammars should be resolved. Additionally, it will be the prototype of the returned object."),(0,i.kt)("h2",{id:"grammar-objects"},"Grammar objects"),(0,i.kt)("p",null,"A Grammar instance ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," has the following methods:"),(0,i.kt)("a",{name:"Grammar.match"},(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"g.match(str: string, optStartRule?: string) \u2192 MatchResult"))),(0,i.kt)("p",null,"Try to match ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," against ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", returning a ",(0,i.kt)("a",{parentName:"p",href:"#matchresult-objects"},"MatchResult"),". If ",(0,i.kt)("inlineCode",{parentName:"p"},"optStartRule")," is given, it specifies the rule on which to start matching. By default, the start rule is inherited from the supergrammar, or if there is no supergrammar specified, it is the first rule in ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),"'s definition."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"g.matcher()")),(0,i.kt)("p",null,"Create a new ",(0,i.kt)("a",{parentName:"p",href:"#matcher-objects"},"Matcher")," object which supports incrementally matching ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," against a changing input string."),(0,i.kt)("a",{name:"Grammar.trace"},(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api",id:"trace"},"g.trace(str: string, optStartRule?: string) \u2192 Trace"))),(0,i.kt)("p",null,"Try to match ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," against ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", returning a Trace object. ",(0,i.kt)("inlineCode",{parentName:"p"},"optStartRule")," has the same meaning as in ",(0,i.kt)("inlineCode",{parentName:"p"},"g.match"),". Trace objects have a ",(0,i.kt)("inlineCode",{parentName:"p"},"toString()")," method, which returns a string which summarizes each parsing step (useful for debugging)."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"g.createSemantics() \u2192 Semantics")),(0,i.kt)("p",null,"Create a new ",(0,i.kt)("a",{parentName:"p",href:"#semantics"},"Semantics")," object for ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),"."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api",id:"extendSemantics"},"g.extendSemantics(superSemantics: Semantics) \u2192 Semantics")),(0,i.kt)("p",null,"Create a new ",(0,i.kt)("a",{parentName:"p",href:"#semantics"},"Semantics")," object for ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," that inherits all of the operations and attributes in ",(0,i.kt)("inlineCode",{parentName:"p"},"superSemantics"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," must be a descendent of the grammar associated with ",(0,i.kt)("inlineCode",{parentName:"p"},"superSemantics"),"."),(0,i.kt)("h2",{id:"matcher-objects"},"Matcher objects"),(0,i.kt)("p",null,"Matcher objects can be used to incrementally match a changing input against the Matcher's grammar, e.g. in an editor or IDE. When a Matcher's input is modified via ",(0,i.kt)("inlineCode",{parentName:"p"},"replaceInputRange"),", further calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," will reuse the partial results of previous calls wherever possible. Generally, this means that small changes to the input will result in very short match times."),(0,i.kt)("p",null,"A Matcher instance ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," has the following methods:"),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"m.getInput() \u2192 string")),(0,i.kt)("p",null,"Return the current input string."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"m.setInput(str: string)")),(0,i.kt)("p",null,"Set the input string to ",(0,i.kt)("inlineCode",{parentName:"p"},"str"),"."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"m.replaceInputRange(startIdx: number, endIdx: number, str: string)")),(0,i.kt)("p",null,"Edit the current input string, replacing the characters between ",(0,i.kt)("inlineCode",{parentName:"p"},"startIdx")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"endIdx")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"str"),"."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"m.match(optStartRule?: string) \u2192 MatchResult")),(0,i.kt)("p",null,"Like ",(0,i.kt)("a",{parentName:"p",href:"#Grammar.match"},"Grammar's ",(0,i.kt)("inlineCode",{parentName:"a"},"match")," method"),", but operates incrementally."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"m.trace(optStartRule?: string) \u2192 Trace")),(0,i.kt)("p",null,"Like ",(0,i.kt)("a",{parentName:"p",href:"#Grammar.trace"},"Grammar's ",(0,i.kt)("inlineCode",{parentName:"a"},"trace")," method"),", but operates incrementally."),(0,i.kt)("h2",{id:"matchresult-objects"},"MatchResult objects"),(0,i.kt)("p",null,"Internally, a successful MatchResult contains a ",(0,i.kt)("em",{parentName:"p"},"parse tree"),", which is made up of ",(0,i.kt)("em",{parentName:"p"},"parse nodes"),". Parse trees are not directly exposed -- instead, they are inspected indirectly through ",(0,i.kt)("em",{parentName:"p"},"operations")," and ",(0,i.kt)("em",{parentName:"p"},"attributes"),", which are described in the next section."),(0,i.kt)("p",null,"A MatchResult instance ",(0,i.kt)("inlineCode",{parentName:"p"},"r")," has the following methods:"),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"r.succeeded() \u2192 boolean")),(0,i.kt)("p",null,"Return ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the match succeeded, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"r.failed() \u2192 boolean")),(0,i.kt)("p",null,"Return ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the match failed, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,i.kt)("h3",{id:"matchfailure-objects"},"MatchFailure objects"),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"r.failed()")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"r")," has the following additional properties and methods:"),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"r.message: string")),(0,i.kt)("p",null,"Contains a message indicating where and why the match failed. This message is suitable for end users of a language (i.e., people who do not have access to the grammar source)."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"r.shortMessage: string")),(0,i.kt)("p",null,"Contains an abbreviated version of ",(0,i.kt)("inlineCode",{parentName:"p"},"r.message")," that does not include an excerpt from the invalid input."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"r.getRightmostFailurePosition() \u2192 number")),(0,i.kt)("p",null,"Return the index in the input stream at which the match failed."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"r.getRightmostFailures() \u2192 Array")),(0,i.kt)("p",null,"Return an array of Failure objects describing the failures the occurred at the rightmost failure position."),(0,i.kt)("h2",{id:"semantics"},"Semantics, Operations, and Attributes"),(0,i.kt)("p",null,"An Operation represents a function that can be applied to a successful match result. Like a ",(0,i.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Visitor_pattern"},"Visitor"),", an operation is evaluated by recursively walking the parse tree, and at each node, invoking the matching semantic action from its ",(0,i.kt)("em",{parentName:"p"},"action dictionary"),"."),(0,i.kt)("p",null,"An Attribute is an Operation whose result is memoized, i.e., it is evaluated at most once for any given node."),(0,i.kt)("p",null,"A Semantics is a family of operations and/or attributes for a given grammar. A grammar may have any number of Semantics instances associated with it \u2014 this means that the clients of a grammar (even in the same program) never have to worry about operation/attribute name clashes."),(0,i.kt)("h3",{id:"semantics-objects"},"Semantics objects"),(0,i.kt)("p",null,"Operations and attributes are accessed by applying a semantics instance to a ",(0,i.kt)("a",{parentName:"p",href:"#matchresult-objects"},"MatchResult"),".\nThis returns a parse node, whose properties correspond to the operations and attributes of the semantics. For example, to invoke an operation named 'prettyPrint': ",(0,i.kt)("inlineCode",{parentName:"p"},"mySemantics(matchResult).prettyPrint()"),". Attributes are accessed using property syntax \u2014 e.g., for an attribute named 'value': ",(0,i.kt)("inlineCode",{parentName:"p"},"mySemantics(matchResult).value"),"."),(0,i.kt)("p",null,"A Semantics instance ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," has the following methods, which all return ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," so they can be chained:"),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"mySemantics.addOperation(nameOrSignature: string, actionDict: object) \u2192 Semantics")),(0,i.kt)("p",null,"Add a new Operation to this Semantics, using the ",(0,i.kt)("a",{parentName:"p",href:"#semantic-actions"},"semantic actions")," contained in ",(0,i.kt)("inlineCode",{parentName:"p"},"actionDict"),". The first argument is either a name (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"'prettyPrint'"),") or a ",(0,i.kt)("em",{parentName:"p"},"signature")," which specifies the operation name and zero or more named parameters (e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"'prettyPrint()'"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"'prettyPrint(depth, strict)'"),"). It is an error if there is already an operation or attribute called ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," in this semantics."),(0,i.kt)("p",null,"If the operation has arguments, they are accessible via ",(0,i.kt)("inlineCode",{parentName:"p"},"this.args")," within a semantic action. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"this.args.depth")," would hold the value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"depth")," argument for the current action."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"mySemantics.addAttribute(name: string, actionDict: object) \u2192 Semantics")),(0,i.kt)("p",null,"Exactly like ",(0,i.kt)("inlineCode",{parentName:"p"},"semantics.addOperation"),", except it will add an Attribute to the semantics rather than an Operation."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"mySemantics.extendOperation(name: string, actionDict: object) \u2192 Semantics")),(0,i.kt)("p",null,"Extend the Operation named ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," with the semantic actions contained in ",(0,i.kt)("inlineCode",{parentName:"p"},"actionDict"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," must be the name of an operation in the super semantics \u2014 i.e., you must first extend the Semantics via ",(0,i.kt)("a",{parentName:"p",href:"#extendSemantics"},(0,i.kt)("inlineCode",{parentName:"a"},"extendSemantics"))," before you can extend any of its operations."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"semantics.extendAttribute(name: string, actionDict: object) \u2192 Semantics")),(0,i.kt)("p",null,"Exactly like ",(0,i.kt)("inlineCode",{parentName:"p"},"semantics.extendOperation"),", except it will extend an Attribute of the super semantics rather than an Operation."),(0,i.kt)("h3",{id:"semantic-actions"},"Semantic Actions"),(0,i.kt)("p",null,"A semantic action is a function that computes the value of an operation or attribute for a specific type of node in the parse tree. There are three different types of parse nodes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Rule application"),", or ",(0,i.kt)("em",{parentName:"li"},"non-terminal")," nodes, which correspond to rule application expressions"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Terminal")," nodes, for string and number literals, and keyword expressions"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Iteration")," nodes, which are associated with expressions inside a ",(0,i.kt)("a",{parentName:"li",href:"/docs/syntax-reference#repetition-operators"},"repetition operator")," (",(0,i.kt)("inlineCode",{parentName:"li"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"+"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"?"),")")),(0,i.kt)("p",null,"Generally, you write a semantic action for each rule in your grammar, and store them together in an ",(0,i.kt)("em",{parentName:"p"},"action dictionary"),". For example, given the following grammar:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Name {\n  FullName = name name\n  name = (letter | "-" | ".")+\n}\n')),(0,i.kt)("p",null,"A set of semantic actions for this grammar might look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const actions = {\n  FullName(firstName, lastName) { ... },\n  name(parts) { ... }\n};\n")),(0,i.kt)("p",null,"The value of an operation or attribute for a node is the result of invoking the node's matching semantic action. In the grammar above, the body of the ",(0,i.kt)("inlineCode",{parentName:"p"},"FullName")," rule produces two values \u2014 one for each application of the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," rule. The values are represented as parse nodes, which are passed as arguments when the semantic action is invoked. An error is thrown if the function arity does not match the number of values produced by the expression."),(0,i.kt)("p",null,"The matching semantic action for a particular node is chosen as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"On a ",(0,i.kt)("em",{parentName:"li"},"rule application")," (non-terminal) node, first look for a semantic action with the same name as the rule (e.g., 'FullName'). If the action dictionary does not have a property with that name, use the action named ",(0,i.kt)("inlineCode",{parentName:"li"},"_nonterminal"),", if it exists. If there is no ",(0,i.kt)("inlineCode",{parentName:"li"},"_nonterminal")," action, and the node has exactly one child, then return the result of invoking the operation/attribute on the child node."),(0,i.kt)("li",{parentName:"ul"},"On a terminal node (e.g., a node produced by the parsing expression ",(0,i.kt)("inlineCode",{parentName:"li"},'"hello"'),"), use the semantic action named ",(0,i.kt)("inlineCode",{parentName:"li"},"_terminal"),"."),(0,i.kt)("li",{parentName:"ul"},"On an iteration node (e.g., a node produced by the parsing expression ",(0,i.kt)("inlineCode",{parentName:"li"},"letter+"),"), use the semantic action named ",(0,i.kt)("inlineCode",{parentName:"li"},"_iter"),".")),(0,i.kt)("span",{id:"special-actions"}),"The `_iter`, `_nonterminal`, and `_terminal` actions are sometimes called _special actions_. `_iter` and `_nonterminal` take a variable number of arguments, which are typically captured into an array using [rest parameter syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters), e.g. `_iter(...children) ","{"," ... ","}","`. The `_terminal` action takes no arguments.",(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},(0,i.kt)("strong",{parentName:"em"},"NOTE:")," Versions of Ohm prior to v16.0 had slightly different behaviour with regards to default semantic actions. See ",(0,i.kt)("a",{parentName:"em",href:"/docs/releases/ohm-js-16.0#default-semantic-actions"},"here")," for more details.")),(0,i.kt)("p",null,"Note that you can also write semantic actions for built-in rules like ",(0,i.kt)("inlineCode",{parentName:"p"},"letter")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"digit"),". For ",(0,i.kt)("inlineCode",{parentName:"p"},"ListOf"),", please see the documentation on ",(0,i.kt)("a",{parentName:"p",href:"#asIteration"},"asIteration")," below."),(0,i.kt)("h3",{id:"parse-nodes"},"Parse Nodes"),(0,i.kt)("p",null,"Each parse node is associated with a particular ",(0,i.kt)("em",{parentName:"p"},"parsing expression")," (a fragment of an Ohm grammar), and the node captures any input that was successfully parsed by that expression. Unlike many parsing frameworks, Ohm does not have a syntax for binding/capturing -- every parsing expression captures all the input it consumes, and produces a fixed number of values."),(0,i.kt)("p",null,"A node ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," has the following methods and properties:"),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"n.child(idx: number) \u2192 Node")),(0,i.kt)("p",null,"Get the child at index ",(0,i.kt)("inlineCode",{parentName:"p"},"idx"),"."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"n.isTerminal() \u2192 boolean")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the node is a terminal node, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"n.isIteration() \u2192 boolean")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the node is an iteration node (i.e., if it associated with a repetition operator in the grammar), otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"n.children: Array")),(0,i.kt)("p",null,"An array containing the node's children."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"n.ctorName: string")),(0,i.kt)("p",null,"The name of grammar rule that created the node."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"n.source: Interval")),(0,i.kt)("p",null,"Captures the portion of the input that was consumed by the node."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api",id:"Node-sourceString"},"n.sourceString: string")),(0,i.kt)("p",null,"The substring of the input that was consumed by the node. Equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"n.source.contents"),"."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"n.numChildren: number")),(0,i.kt)("p",null,"The number of child nodes that the node has."),(0,i.kt)("b",null,(0,i.kt)("pre",{class:"api"},"n.isOptional() \u2192 boolean")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the node is an iterator node having either one or no child (? operator), otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,i.kt)("h4",{id:"operations-and-attributes"},"Operations and Attributes"),(0,i.kt)("p",null,"In addition to the properties listed above, within a given semantics, every node also has a method/property corresponding to each operation/attribute in the semantics. For example, in a semantics that has an operation named 'prettyPrint' and an attribute named 'freeVars', every node has a ",(0,i.kt)("inlineCode",{parentName:"p"},"prettyPrint()")," method and a ",(0,i.kt)("inlineCode",{parentName:"p"},"freeVars")," property."),(0,i.kt)("h2",{id:"built-in-operations"},"Built-in Operations"),(0,i.kt)("h3",{id:"asiteration"},"asIteration"),(0,i.kt)("p",null,"The built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"asIteration")," operation offers a convenient way of handling ",(0,i.kt)("em",{parentName:"p"},"ListOf")," expressions, by adapting them to have the same interface as built-in iteration nodes. As an example, take the following grammar:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'G {\n  Start = ListOf<letter, ",">\n}\n')),(0,i.kt)("p",null,"...and an operation defined as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"s.addOperation('upper()', {\n  Start(list) {\n    return list.asIteration().children.map(c => c.upper());\n  },\n  letter(l) {\n    return this.sourceString.toUpperCase();\n  }\n});\n")),(0,i.kt)("p",null,"Then ",(0,i.kt)("inlineCode",{parentName:"p"},"s(g.match('a, b, c')).upper()")," will return ",(0,i.kt)("inlineCode",{parentName:"p"},"['A', 'B', 'C']"),". Note that calling ",(0,i.kt)("inlineCode",{parentName:"p"},"upper()")," on the result of ",(0,i.kt)("inlineCode",{parentName:"p"},"asIteration")," implicitly maps the ",(0,i.kt)("inlineCode",{parentName:"p"},"upper")," operation over each element of the list."),(0,i.kt)("p",null,"You can also extend the ",(0,i.kt)("inlineCode",{parentName:"p"},"asIteration")," operation to handle other list-like rules in your own language."))}h.isMDXComponent=!0}}]);