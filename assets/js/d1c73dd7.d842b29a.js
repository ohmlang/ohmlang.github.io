"use strict";(self.webpackChunkohmjs_org=self.webpackChunkohmjs_org||[]).push([[183],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return c}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=i.createContext({}),p=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},m=function(e){var n=p(e.components);return i.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},d=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(t),c=a,h=d["".concat(l,".").concat(c)]||d[c]||u[c]||r;return t?i.createElement(h,o(o({ref:n},m),{},{components:t})):i.createElement(h,o({ref:n},m))}));function c(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var p=2;p<r;p++)o[p]=t[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}d.displayName="MDXCreateElement"},2651:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return l},default:function(){return c},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return u}});var i=t(3117),a=t(102),r=(t(7294),t(3905)),o=["components"],s={},l="Parsing indentation sensitive languages",p={unversionedId:"indentation-sensitive",id:"indentation-sensitive",title:"Parsing indentation sensitive languages",description:"As of v17, Ohm has experimental support for indentation-sensitive languages. This will make it possible to write Ohm grammars for languages like Python and YAML. NOTE: as this is API is experimental, it is outside the scope of semver \u2014\xa0which means that we may make breaking changes to the API without a change to Ohm's major version number.",source:"@site/docs/indentation-sensitive.md",sourceDirName:".",slug:"/indentation-sensitive",permalink:"/docs/indentation-sensitive",editUrl:"https://github.com/harc/ohm/edit/main/doc/indentation-sensitive.md",tags:[],version:"current",frontMatter:{}},m={},u=[{value:"Background",id:"background",level:2},{value:"Making indentation-sensitive grammars",id:"making-indentation-sensitive-grammars",level:2},{value:"Implementation details",id:"implementation-details",level:2},{value:"Examples",id:"examples",level:2},{value:"Notes and open questions",id:"notes-and-open-questions",level:2}],d={toc:u};function c(e){var n=e.components,t=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"parsing-indentation-sensitive-languages"},"Parsing indentation sensitive languages"),(0,r.kt)("p",null,"As of v17, Ohm has experimental support for indentation-sensitive languages. This will make it possible to write Ohm grammars for languages like Python and YAML. ",(0,r.kt)("strong",{parentName:"p"},"NOTE:")," as this is API is experimental, it is outside the scope of semver \u2014\xa0which means that we may make breaking changes to the API without a change to Ohm's major version number."),(0,r.kt)("h2",{id:"background"},"Background"),(0,r.kt)("p",null,"The Ohm language is based on parsing expression grammars (PEGs), and pure PEGs can't express indentation sensitivity. The usual trick is to pre-process the input and insert explicit ",(0,r.kt)("inlineCode",{parentName:"p"},"indent")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"dedent")," tokens, then parse the modified output. While this works, it has a few downsides:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Error messages can be confusing, as they refer to the modified input rather than the original input"),(0,r.kt)("li",{parentName:"ul"},'You can\'t use the "real" syntax in the Ohm Editor \u2014\xa0your examples inputs need to be pre-processed'),(0,r.kt)("li",{parentName:"ul"},"The preprocessing step is trickier than you might think!")),(0,r.kt)("p",null,"For these reasons, we decided to add built-in support for indentation-sensitive languages."),(0,r.kt)("h2",{id:"making-indentation-sensitive-grammars"},"Making indentation-sensitive grammars"),(0,r.kt)("p",null,"To define an indentation-sensitive language, create a grammar that inherits from ",(0,r.kt)("inlineCode",{parentName:"p"},"ExperimentalIndentationSensitive"),". For example, here is a grammar for language support nested lists of bullet points:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'import * as ohm from \'ohm-js\';\n\nconst outline = ohm.grammar(\n  String.raw`\n    Outline <: IndentationSensitive {\n      Items = Item+\n      Item = "-" label indent Items dedent  -- withChildren\n          | "-" label  -- leaf\n\n      label = (~newline any)* eol\n\n      eol = newline | end\n      newline = "\\r\\n" | "\\r" | "\\n"\n      spaces := (~newline space)*\n    }\n`,\n  {IndentationSensitive: ohm.ExperimentalIndentationSensitive}\n);\n')),(0,r.kt)("h2",{id:"implementation-details"},"Implementation details"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"indent")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"dedent")," rules are primitive rules defined by ",(0,r.kt)("inlineCode",{parentName:"p"},"ExperimentalIndentationSensitive"),". You can think of them as special characters that automatically inserted at the appropriate points \u2014 except that they take up no width in the input stream. They are inserted immediately after the associated indentation characters at the beginning of the line. For example, here is some Python code, with comments indicating where the indents and dedents are inserted:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'if col == 3:\n  if row == 4: #   # <~~ indent at position 2 on this line\n    print("bingo") # <~~ indent at position 4\n  print("done")    # <~~ dedent at position 2\n')),(0,r.kt)("p",null,"There is also final dedent at the end of the input."),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("p",null,"See examples/indentation-sensitive for an example you can experiment with."),(0,r.kt)("h2",{id:"notes-and-open-questions"},"Notes and open questions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The current implementation ",(0,r.kt)("em",{parentName:"li"},"only")," works with spaces (not tabs). Among the indentation-sensitive languages (Python, YAML, Elm, etc.) there are small difference in what characters they allow and how they treat them. We probably want to make this customizable in some way.")))}c.isMDXComponent=!0}}]);